/include/ "zynq.dtsi"

/ {
	model = "Topic Zynq Miami";

	/* Arrange that UART0 is ttyPS0 */
	aliases {
		serial0 = &uart0;
		serial1 = &uart1;
	};

	memory {
		device_type = "memory";
		reg = <0x000000000 0x20000000>;
	};

	chosen {
		/* Boot using squashfs system, nice for QSPI NOR flash */
		bootargs = "console=ttyPS0,115200 root=/dev/mtdblock5 ro rootfstype=squashfs rootwait quiet";
		/* bootargs = "console=ttyPS0,115200 ubi.mtd=qspi-rootfs root=ubi0:qspi-rootfs rw rootfstype=ubifs rootwait"; */
		linux,stdout-path = "/amba@0/uart@e0000000";
	};

	/* Represents the 3v3 supply on the Miami SOM. */
	reg_3v3_miami: regulator_3v3_miami {
		compatible = "regulator-fixed";
		regulator-name = "3v3-miami";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
	};
};

&sdhci0 {
	disable-wp; /* We don't have a write-protect detection */
};

&primary_flash {
	/* Specify flash chip to expect */
	compatible = "n25q256a";
	/* Max frequency for quad read is 108MHz according to data sheet */
	spi-max-frequency = <108000000>;
	/* Flash chip is 32MB, so add 16MB to the rootfs partition */
	partition@qspi-rootfs {
		label = "qspi-rootfs";
		reg = <0x480000 0x1b80000>;
	};
	/* Everything? */
	partition@qspi-all {
		label = "qspi-all";
		reg = <0x0 0x2000000>;
	};
};

&axi {
		ps7_i2c_0: ps7-i2c@e0004000 {
			bus-id = <0>;
			clocks = <&clkc 38>;
			compatible = "cdns,i2c-r1p10";
			clock-frequency = <400000>;
			interrupt-parent = <&gic>;
			interrupts = <0 25 4>;
			reg = <0xe0004000 0x1000>;
			xlnx,has-interrupt = <0x0>;
			#address-cells = <1>;
			#size-cells = <0>;
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_i2c0_default>;
		};

		ps7_i2c_1: ps7-i2c@e0005000 {
			clock-frequency = <400000>;
			clocks = <&clkc 39>;
			compatible = "cdns,i2c-r1p10";
			interrupt-parent = <&gic>;
			interrupts = <0 48 4>;
			reg = <0xe0005000 0x1000>;
			xlnx,has-interrupt = <0x0>;
			#address-cells = <1>;
			#size-cells = <0>;
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_i2c1_default>;
			/* AD converter for voltage monitoring */
			monitorvolt: ad799x@29 {
				compatible = "ad7999";
				reg = <0x29>;
				vcc-supply = <&reg_3v3_miami>;
				vref-supply = <&reg_3v3_miami>;
			};
			/* GPIO expander */
			gpioex: pca953x@41 {
				compatible = "nxp,pca9536";
				reg = <0x41>;
				/* 0=USB_RESET 1=VTT_SHDWN_N 2=V_PRESENT 3=DEBUG_PRESENT */
				gpio-controller;
				#gpio-cells = <2>;
			};
			/* Current monitoring chip */
			monitorcurrent: ltc2990@4C {
				compatible = "ltc2990";
				reg = <0x4C>;
			};
			/* EEPROM */
			eeprom: eeprom@50 {
				compatible = "at24,24c04";
				reg = <0x50>;
			};
			/* IO Voltage controller */
			ltc3562: ltc3562@65 {
				compatible = "lltc,ltc3562";
				reg = <0x65>; /* 0b1100101 */
				regulators {
					R400B_reg: R400B {
						/* Supplies VCCO2 to bank 34 */
						regulator-min-microvolt = <1800000>;
						regulator-max-microvolt = <1800000>;
						regulator-boot-on;
						regulator-always-on;
						lltc,operating-mode = <1>;
					};
					R600B_reg: R600B {
						/* Supplies VCCO0 to Bank 13 */
						regulator-min-microvolt = <3300000>;
						regulator-max-microvolt = <3300000>;
						regulator-boot-on;
						regulator-always-on;
					};
					/* R400A Not connected */
					R600A_reg: R600A {
						/* Supplies VCCO1 to bank 35 */
						/* We actually want 1v8, but the wiring of
						 * the regulator is weird so you can only get
						 * 1768mV */
						regulator-min-microvolt = <1768000>;
						regulator-max-microvolt = <1768000>;
						lltc,fb-voltage-divider = <316 100>;
						regulator-boot-on;
						regulator-always-on;
					};
				};
			};
		};

		smcc: memory-controller@e000e000 {
			#address-cells = <1>;
			#size-cells = <1>;
			status = "disabled";
			clock-names = "memclk", "aclk";
			clocks = <&clkc 11>, <&clkc 44>;
			compatible = "arm,pl353-smc-r2p1";
			interrupt-parent = <&gic>;
			interrupts = <0 18 4>;
			ranges ;
			reg = <0xe000e000 0x1000>;
			nand0: flash@e1000000 {
				status = "disabled";
				compatible = "arm,pl353-nand-r2p1";
				reg = <0xe1000000 0x1000000>;
				pinctrl-names = "default";
				pinctrl-0 = <&pinctrl_smc0_nand_default>;

				/* Micron MT29F2G16ABBFAH4 timings */
				arm,nand-cycle-t0 = <0x4>;
				arm,nand-cycle-t1 = <0x4>;
				arm,nand-cycle-t2 = <0x1>;
				arm,nand-cycle-t3 = <0x2>;
				arm,nand-cycle-t4 = <0x2>;
				arm,nand-cycle-t5 = <0x2>;
				arm,nand-cycle-t6 = <0x4>;

				#address-cells = <0x1>;
				#size-cells = <0x1>;
				partition@nand-all {
					label = "nand-all";
					reg = <0x0 0x10000000>; /* 256 MB */
				};
				/* to mount as UBI:
				   ubiattach /dev/ubi_ctrl -m 0
				   ubimkvol /dev/ubi0 -N nand -m
				   mkdir /media/nand
				   mount -t ubifs /dev/ubi0_0 /media/nand
				 */
			};
			nor0: flash@e2000000 {
				status = "disabled";
				compatible = "cfi-flash";
				reg = <0xe2000000 0x2000000>;
				#address-cells = <1>;
				#size-cells = <1>;
			};
		};
};

/ {
	leds: leds {
		compatible = "gpio-leds";
		alive {
			label = "alive:green";
			gpios = <&gpio 25 0>;
			linux,default-trigger = "heartbeat";
		};
	};
};

&uart0 {
	status = "okay";
};

&eth {
	status = "disabled";
};

&usb {
	status = "disabled";
};

&qspi0 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_qspi0_default>;
};

&pinctrl0 {
	pinctrl_qspi0_default: qspi0_default {
		mux {
			groups = "qspi0_0_grp";
			function = "qspi0";
		};
		mux-fbclk {
			groups = "qspi_fbclk_grp";
			function = "qspi_fbclk";
		};
		conf {
			groups = "qspi0_0_grp", "qspi_fbclk_grp";
			slew-rate = <0>;
			io-standard = <1>;
			bias-disable;
		};
	};

	pinctrl_smc0_nand_default: smc0_nand_default {
		mux {
			groups = "smc0_nand_grp";
			function = "smc0_nand";
		};
	};

	pinctrl_i2c0_default: i2c0-default {
		mux {
			groups = "i2c0_10_grp";
			function = "i2c0";
		};

		conf {
			groups = "i2c0_10_grp";
			bias-pull-up;
			slew-rate = <0>;
			io-standard = <1>;
		};
	};

	pinctrl_i2c1_default: i2c1-default {
		mux {
			groups = "i2c1_10_grp";
			function = "i2c1";
		};

		conf {
			groups = "i2c1_10_grp";
			bias-pull-up;
			slew-rate = <0>;
			io-standard = <1>;
		};
	};
};
